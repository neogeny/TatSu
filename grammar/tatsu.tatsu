# Copyright (c) 2017-2026 Juancarlo AÃ±ez (apalala@gmail.com)
# SPDX-License-Identifier: BSD-4-Clause
@@grammar :: TatSu
@@whitespace :: /(?m)\s+/
@@comments :: ?"(?ms)[(][*]\s*((?:.|\n)*?)\s*[*][)]|[\/][*]\s*((?:.|\n)*?)\s*[*][\/]"
@@eol_comments :: ?"(?ms)(?:[#]|[\/][\/])(.*?)$"
@@parseinfo :: True
@@left_recursion :: False


start = grammar ;


grammar::Grammar =
    title:`TATSU`
    {directives+:directive | keywords+:keyword}
    rules+:rule {rules+:rule | keywords+:keyword}
    $
    ;


directive = '@@' !'keyword' ~
    (
        | name:('comments' | 'eol_comments') ~ '::' ~ value:regex
        | name:('whitespace') ~ '::' ~ value:(regex|string|'None'|'False'|`None`)
        | name:('nameguard' | 'ignorecase' | 'left_recursion' | 'parseinfo' | 'memoization')
            ~
            ('::' ~ value:boolean|value:`True`)
        | name:('grammar') ~ '::' ~ value:word
        | name:('namechars') ~ '::' ~ value:string
    ) ~
    ;

keywords = { keywords }+ ;

keyword = '@@keyword' ~ '::' ~ {@+:(word|string) !(':'|'=')} ;

paramdef =
    | /* no keyword params if ':: */ '::' ~ params:params
    | '(' ~
            (
            | kwparams:kwparams
            | params:params ',' ~ kwparams:kwparams
            | params:params
            )
       ')'
    | '[' ~
            (
            | kwparams:kwparams
            | params:params ',' ~ kwparams:kwparams
            | params:params
            )
       ']'
    ;

rule::Rule =
    decorators:{decorator}
    name:name
    ~
    [>paramdef]
    ['<' ~ base:known_name]
    ('=' | ':=' | ':' )
    ~
    exp:expre
    RULE_END
    ~
    ;

RULE_END = (EMPTYLINE [';']|$|';') ;

EMPTYLINE = /(?:\s*(?:\r?\n|\r)){2,}/ ;

decorator = '@' !'@' ~ @:('override'|'name'|'nomemo') ;

params = @+:first_param {',' @+:literal !'=' ~ } ;

first_param = path | literal ;

kwparams = ','.{pair}+ ;

pair = @+:word '=' ~ @+:literal ;

expre = choice | sequence ;

choice::Choice = ['|' ~] @+:option {'|' ~ @+:option}+ ;

option::Option = @:sequence ;

sequence::Sequence =
    | &(element ',') ','.{element}+
    | {!EMPTYLINE element}+
    ;

element = rule_include | named | override | term ;

rule_include::RuleInclude = '>' ~ @:known_name ;

named = named_list | named_single ;

named_list::NamedList = name:name '+:' ~ exp:term ;

named_single::Named = name:name ':' ~ exp:term ;

override = override_list | override_single | override_single_deprecated ;

override_list::OverrideList = '@+:' ~ @:term ;

override_single::Override = '@:' ~ @:term ;

override_single_deprecated::Override = '@' ~ @:term ;

term =
    | void
    | gather
    | join
    | left_join
    | right_join
    | empty_closure
    | positive_closure
    | closure
    | optional
    | skip_to
    | lookahead
    | negative_lookahead
    | cut
    | cut_deprecated
    | atom
    ;

group::Group = '(' ~ @:expre ')' ~ ;


gather = &(atom '.{') ~ (positive_gather | normal_gather)
    ;


positive_gather::PositiveGather = sep:atom '.{' exp:expre '}' ('+'|'-') ~ ;

normal_gather::Gather = sep:atom '.{' ~ exp:expre '}' ['*' ~] ~ ;

join = &(atom '%{') ~ (positive_join | normal_join) ;

positive_join::PositiveJoin = sep:atom '%{' exp:expre '}' ('+'|'-') ~ ;

normal_join::Join = sep:atom '%{' ~ exp:expre '}' ['*' ~] ~ ;

left_join::LeftJoin = sep:atom '<{' ~ exp:expre '}' ('+'|'-') ~ ;

right_join::RightJoin = sep:atom '>{' ~ exp:expre '}' ('+'|'-') ~ ;

positive_closure::PositiveClosure = '{' @:expre '}' ('-' | '+') ~ |   @:atom '+' ~ ;

closure::Closure = '{' @:expre '}' ['*'] ~ |   @:atom '*' ~ ;


empty_closure::EmptyClosure = '{}' ~ @:() ;

optional::Optional = '[' ~ @:expre ']' ~ |   @:atom !('?"' | "?'" | '?/') '?'  ~ ;

lookahead::Lookahead = '&' ~ @:term ;

negative_lookahead::NegativeLookahead = '!' ~ @:term ;

skip_to::SkipTo = '->' ~ @:term ;

atom = group | token | alert | constant | call | pattern | dot | eof ;

call::Call = word ;

void::Void = '()' ~ ;

fail::Fail = '!()' ~ ;

cut::Cut = '~' ~ ;

cut_deprecated::Cut = '>>' ~ ;

known_name = name ~ ;

name = word ;

constant::Constant = &"`"
    (
        | /(?ms)```((?:.|\n)*?)```/
        | "`" @:literal "`"
        | /`(.*?)`/
    )
    ;

alert::Alert = level:/\^+/ message:constant ;

token::Token = string | raw_string ;

literal = string | raw_string | boolean | word | hex | float | int | null ;

string = STRING ;

raw_string = /r/ @:STRING ;

STRING =
    | @:/"((?:[^"\n]|\\"|\\\\)*?)"/ ~
    | @:/'((?:[^'\n]|\\'|\\\\)*?)'/ ~
    ;

hex = /0[xX](?:\d|[a-fA-F])+/ ;

float = /[-+]?(?:\d+\.\d*|\d*\.\d+)(?:[Ee][-+]?\d+)?/ ;

int = /[-+]?\d+/ ;

path = /(?!\d)\w+/ + /(?:::(?!\d)\w+)+/ ;

word = /(?!\d)\w+/ ;

dot::Dot = '/./' ;

pattern::Pattern = regexes ;

regexes = '+'.{regex}+ ;

regex =
    | '/' ~ @:?"(?:[^/\\]|\\/|\\.)*" '/' ~
    | '?' @:STRING
    | deprecated_regex
    ;

deprecated_regex = '?/' ~ @:?"(?:.|\n)*?(?=/\?)" ?"/\?+" ~ ;

boolean = 'True' | 'False' ;

null = 'None' ;

eof::EOF = '$' ~ ;
