# Models

## Building Models

Naming elements in grammar rules makes the parser discard uninteresting
parts of the input, like punctuation, to produce an *Abstract Syntax
Tree* ([AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree)) that
reflects the semantic structure of what was parsed. But an
[AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree) doesn\'t carry
information about the rule that generated it, so navigating the trees
may be difficult.

{{TatSu}} defines the
`tatsu.semantics.ModelBuilderSemantics` semantics class which helps
construct object models from abstract syntax trees:

``` python
from tatsu.semantics import ModelBuilderSemantics

parser = MyParser(semantics=ModelBuilderSemantics())
```

Then you add the desired node type as first parameter to each grammar
rule:

Builder semantics are enabled by passing [asmodel=True]{.title-ref} to
the `tatsu.compile()` or `tatsu.parse()` functions.

``` ocaml
addition::AddOperator = left:mulexpre '+' right:addition ;
```

`ModelBuilderSemantics` will synthesize a `class AddOperator(Node):`
class and use it to construct the node. The synthesized class will have
one attribute with the same name as each of the named elements in the
rule.

You can also use [Python](http://python.org)\'s built-in types as node
types, and `ModelBuilderSemantics` will do the right thing:

``` ocaml
integer::int = /[0-9]+/ ;
```

`ModelBuilderSemantics` acts as any other semantics class, so its
default behavior can be overridden by defining a method to handle the
result of any particular grammar rule.

## Generating Models

To take a look at what the classes for the grammar look like, or to be
able to override them, the `tatsu` commandline tool will generate a
module definition with the required classes:

``` bash
$ tatsu --object-model mygrammar.ebnf
```

You can capture the output, or specify the module filename with the
`--object-model-outfile` option to `tatsu`.

``` bash
$ tatsu --object-model-outfile mymodel.py mygrammar.ebnf
```

{{TatSu}} will generate a
`mymodel.MyModelBuilder` that can be passed as semantics to the
`parse()` function to make it generate objects from the model according
to rule declarations:

``` python
model = tatsu.parse(mygrammar_str, text, semantics=mymodel.MyModelBuilder())
```

| NOTE: You must pass an instance of `MyModelBuilder`, and not the class
  name.

## Defining Custom Models

{{TatSu}} allows any definition of model
classes:

``` python
class Expression:
    ...

class Addition(Expression):
    ...
```

But there\'s loss of functionality if model classes are not subclasses
of `objectmodel.Node` (no `node.children()`, `node.parseinfo`,
`node.parent`, `...`). For complete functionality it is better if custom
model clases inherit from `objectmodel.Node` and are defined as
`@dataclass` configured the {{TatSu}}
way:

``` python
from dataclasses import dataclass
from tatsu.objectmodel import Node, TatSuDataclassParams

@dataclass(**TatSuDataclassParams)
class Expression(Node):
    ...

@dataclass(**TatSuDataclassParams)
class Addition(Expression):
    ...
```

Once the custom model classes are defined,
{{TatSu}}\'s entry points need to know
about them, and there are several flexible ways to do that:

``` python
from . import model

ct = {
    'Expression': model.Expression,
    'Addition': model.Addition,
}
result = tatsu.parse(grammar_str, text, constructors=ct)
```

``` python
from tatsu.builder import types_defined_in

ct = types_defined_in(globals())
result = tatsu.parse(grammar_str, text, constructors=ct)
```

``` python
from tatsu.builder import types_defined_in
from . import model

ct = types_defined_in(model)
result = tatsu.parse(grammar_str, text, constructors=ct)
```

``` python
from . import model

result = tatsu.parse(grammar_str, text, typedefs=model)
```

``` python
from . import model

grammar_model = tatsu.compile(gramar_str, typedefs=model)
result = grammar_model.parse(text)
```

Passing `constructors=` or `typedefs=` to the
{{TatSu}} API implies that a model
instead of an [AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree)
is being requested (`asmodel=True`).

## Viewing Models as JSON

Models generated by {{TatSu}} can be
viewed by converting them to a JSON-compatible structure with the help
of `tatsu.util.asjson()`. The protocol tries to provide the best
representation for common types, and can handle any type using `repr()`.
There are provisions for structures with back-references, so there\'s no
infinite recursion.

``` python
import json

print(json.dumps(asjson(model), indent=2))
```

The `model`, with richer semantics, remains unaltered.

Conversion to a JSON-compatible structure relies on the protocol defined
by `tatsu.utils.asjson.AsJSONMixin`. The mixin defines a `__json__()`
method that allows classes to define their best translation.

You can use `AsJSONMixin` as a base class in your own models to take
advantage of `asjson()`, and you can specialize the conversion by
overriding `AsJSONMixin.__json__()`.

``` python
def __json__(self, seen: set[int] | None = None) -> Any:
    ...
```

An easy way to restrict what goes into the JSON output is to override
the `__pubdict__()` method in classes that inherit from `AsJSONMixin`.

``` python
def __pubdict__(self) -> dict[str, Any]:
    ...
```

You can also write your own version of `asjson()` to handle special
cases that are recurrent in your context.

## Walking Models

The class `tatsu.walkers.NodeWalker` allows for the easy traversal
(*walk*) a model constructed with a `ModelBuilderSemantics` instance:

``` python
from tatsu.walkers import NodeWalker

class MyNodeWalker(NodeWalker):

    def walk_AddOperator(self, node):
        left = self.walk(node.left)
        right = self.walk(node.right)

        print('ADDED', left, right)

model = MyParser(semantics=ModelBuilderSemantics()).parse(input)

walker = MyNodeWalker()
walker.walk(model)
```

When a method with a name like `walk_AddOperator()` is defined, it will
be called when a node of that type is *walked*. The *pythonic* version
of the class name may also be used for the *walk* method:
`walk__add_operator()` (note the double underscore).

If a *walk* method for a node class is not found, then a method for the
class\'s bases is searched, so it is possible to write *catch-all*
methods such as:

``` python
def walk_Node(self, node):
    print('Reached Node', node)

def walk_str(self, s):
    return s

def walk_object(self, o):
    raise Exception(f'Unexpected type {type(o).__name__} walked')
```

Which nodes get *walked* is up to the `NodeWalker` implementation. Some
strategies for walking *all* or *most* nodes are implemented as classes
in `tatsu.walkers`, such as `PreOrderWalker` and `DepthFirstWalker`.

Sometimes nodes must be walked more than once for the purpose at hand,
and it\'s up to the walker how and when to do that.

Take a look at `tatsu.ngcodegen.PythonCodeGenerator` for the walker that
generates a parser in Python from the model of a parsed grammar.

## Model Class Hierarchies

It is possible to specify a a base class for generated model nodes:

``` ocaml
additive
    =
    | addition
    | substraction
    ;

addition::AddOperator::Operator
    =
    left:mulexpre op:'+' right:additive
    ;

substraction::SubstractOperator::Operator
    =
    left:mulexpre op:'-' right:additive
    ;
```

{{TatSu}} will generate the base class if it\'s not already known.

Base classes can be used as the target class in *walkers*, and in *code
generators*:

``` python
class MyNodeWalker(NodeWalker):
    def walk_Operator(self, node):
        left = self.walk(node.left)
        right = self.walk(node.right)
        op = self.walk(node.op)

        print(type(node).__name__, op, left, right)
```
