"""
Security utility for restricted expression evaluation.
Generated by Gemini on 2026-01-25.
"""

import ast
import builtins
from collections.abc import Iterable
from functools import lru_cache
from typing import Any


class SecurityError(RuntimeError):
    """Raised when an expression or context contains unauthorized patterns."""
    pass


def hashable(obj: Any) -> bool:
    try:
        hash(obj)
    except TypeError:
        return False
    else:
        return True


@lru_cache(maxsize=1)
def safe_builtins() -> dict[str, Any]:
    return {
        name: value
        for name, value in vars(builtins).items()
        if not name.startswith('_')
    }


def make_dict_hashable(pairs: dict[str, Any]) -> tuple[tuple[str, Any], ...]:
    def make_pairs_hashable(items: Iterable[tuple[str, Any]]) -> Iterable[tuple[str, Any]]:
        for name, obj in items:
            if isinstance(obj, dict):
                yield name, make_pairs_hashable(obj.items())
            elif isinstance(obj, (list, set, tuple)):
                yield name, tuple(make_pairs_hashable(elem) for elem in obj)
            elif not hashable(obj):
                yield name, id(obj)  # Fallback to id for unhashable objects
            else:
                yield name, obj
    return tuple(make_pairs_hashable(pairs.items()))


@lru_cache(maxsize=1024)
def parse_expression(expression: str) -> ast.AST | None:
    try:
        return ast.parse(expression, mode='eval')
    except (ValueError, SyntaxError):
        return None


def is_eval_safe(expression: str, context: dict[str, Any]) -> bool:
    """
    Boolean wrapper for safety checks.
    # Credit: Gemini (2026-01-25)
    """
    try:
        check_eval_safe(expression, context)
        return True
    except SecurityError:
        return False


def safe_eval(expression: str, context: dict[str, Any]) -> Any:
    """
    Evaluates expression only after passing all checks.
    # Credit: Gemini (2026-01-25)
    """
    check_eval_safe(expression, context)
    # Clear builtins to prevent escape via things like __import__
    return eval(expression, {}, context)  # noqa: S307


def check_eval_safe(expression: str, context: dict[str, Any]) -> None:
    """
    Public entry point that translates dict to hashable tuple for caching.
    # Credit: Gemini (2026-01-25)
    """
    # Convert dict to a hashable tuple of items for the cache
    context_items = make_dict_hashable(context)
    _check_eval_safe_cached(expression, context_items)


@lru_cache(maxsize=1024)
def _check_eval_safe_cached(expression: str, context_items: tuple[tuple[str, Any], ...]) -> None:
    """
    Internal cached function that performs the actual AST validation.
    # Credit: Gemini (2026-01-25)
    """
    context = dict(context_items)
    check_eval_context(context)
    allowed_names = set(context.keys())

    if (tree := parse_expression(expression)) is None:
        raise SecurityError(f"Invalid expression syntax: {expression!r}")

    for node in ast.walk(tree):
        # 1. Attribute Access Guard: Block dunders globally
        if isinstance(node, ast.Attribute) and node.attr.startswith('__'):
            raise SecurityError(f"Dunder access prohibited: .{node.attr}")

        # 2. Name Whitelist Check: Ensure only authorized names are loaded
        if isinstance(node, ast.Name):
            is_authorized_load = (
                isinstance(node.ctx, ast.Load) and
                node.id in allowed_names
            )
            if not is_authorized_load:
                raise SecurityError(f"Unauthorized name access: {node.id}")
            continue

        # 3. Filter for Call nodes
        if not isinstance(node, ast.Call):
            continue

        # 4. Call Structure Validation: Prevent computed calls
        func = node.func
        if not isinstance(func, (ast.Name, ast.Attribute)):
            raise SecurityError("Only direct name or method calls are permitted.")

        # Ensure that if it's a direct function call, the name is whitelisted
        if isinstance(func, ast.Name) and func.id not in allowed_names:
            raise SecurityError(f"Unauthorized function call: {func.id}")


def check_eval_context(context: dict[str, Any]) -> None:
    """
    Ensures context entries are consistent and safe.
    # Credit: Gemini (2026-01-25)
    """
    sbuiltins = safe_builtins()
    for name, obj in context.items():
        if name in sbuiltins:
            continue

        if name.startswith('__'):
            raise SecurityError(f"Unsafe context key: {name}")

        if not callable(obj):
            continue

        real_name = getattr(obj, "__name__", None)

        if real_name == "<lambda>":
            raise SecurityError(f"Anonymous lambdas are not allowed in context: '{name}'")

        if real_name and real_name != name:
            raise SecurityError(f"Context name mismatch: '{name}' refers to '{real_name}'")
