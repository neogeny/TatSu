# Copyright (c) 2017-2026 Juancarlo AÃ±ez (apalala@gmail.com)
# SPDX-License-Identifier: BSD-4-Clause
from __future__ import annotations

import codecs
import keyword
import re
from io import StringIO
from typing import Any


def regexp(text: Any) -> str:
    """
    Returns the content of a string formatted as an r'...' literal.
    Escapes control characters and internal single quotes.
    """
    # by [apalala@gmail.com](https://github.com/apalala)
    # by Gemini (2026-02-02)

    if isinstance(text, re.Pattern):
        text = text.pattern
    else:
        text = str(text)

    ctrl_map: dict[str, str] = {
        # Standard Whitespace/Formatting
        "\n": r"\n",    # Linefeed
        "\r": r"\r",    # Carriage Return
        "\t": r"\t",    # Horizontal Tab
        "\v": r"\v",    # Vertical Tab
        "\f": r"\f",    # Formfeed
        "\b": r"\b",    # Backspace
        "\a": r"\a",    # ASCII Bell

        # Quotes and Backslashes
        # "\"": r'"',     # Double Quote
        "'": r"\'",     # Single Quote: wrapping will be single quote, so escape
        # "\\": r"\\",    # Literal Backslash: don't mess with these

        # Null Character (often forgotten)
        "\0": r"\0",    # Null char
    }

    content = text
    # filter out incorrect escapes that modern python compilers rejects
    content = re.sub(r'\\([\'"])', r'\1', content)
    content = ''.join(ctrl_map.get(c, c) for c in content)  # pyright: ignore[reportCallIssue, reportArgumentType]
    content = content.replace(r"\\'", r"\'")
    if content.endswith("\\") and (len(content) - len(content.rstrip("\\"))) % 2 != 0:
        content += "\\"

    return f"r'{content}'"


def eval_escapes(s: str | bytes) -> str | bytes:
    """
    Given a string, evaluate escape sequences starting with backslashes as
    they would be evaluated in Python source code. For a list of these
    sequences, see: https://docs.python.org/3/reference/lexical_analysis.html

    This is not the same as decoding the whole string with the 'unicode-escape'
    codec, because that provides no way to handle non-ASCII characters that are
    literally present in the string.
    """
    # by Rob Speer

    escape_sequence_re: re.Pattern = re.compile(
        r"""(?ux)
        ( \\U........      # 8-digit Unicode escapes
        | \\u....          # 4-digit Unicode escapes
        | \\x..            # 2-digit Unicode escapes
        | \\[0-7]{1,3}     # Octal character escapes
        | \\N\{[^}]+\}     # Unicode characters by name
        | \\[\\'"abfnrtv]  # Single-character escapes
        )""",
    )

    def decode_match(match):
        return codecs.decode(match.group(0), 'unicode-escape')

    return escape_sequence_re.sub(decode_match, s)  # type: ignore[no-matching-overload]


def trim(text, tabwidth=4):
    """
    Trim text of common, leading whitespace.

    Based on the trim algorithm of PEP 257:
        http://www.python.org/dev/peps/pep-0257/
    """
    if not text:
        return ''
    lines = text.expandtabs(tabwidth).splitlines()
    maxindent = len(text)
    indent = maxindent
    for line in lines[1:]:
        stripped = line.lstrip()
        if stripped:
            indent = min(indent, len(line) - len(stripped))
    trimmed = [lines[0].strip()] + [
        line[indent:].rstrip() for line in lines[1:]
    ]
    i = 0
    while i < len(trimmed) and not trimmed[i]:
        i += 1
    return '\n'.join(trimmed[i:])


def indent(text, indent=1, multiplier=4):
    """Indent the given block of text by indent*4 spaces"""
    if text is None:
        return ''
    text = str(text)
    if indent >= 0:
        sindent = ' ' * multiplier * indent
        text = '\n'.join((sindent + t).rstrip() for t in text.splitlines())
    return text


def safe_name(name: str, plug: str = "_") -> str:
    """
    Utility to transform a string into a valid Python identifier.
    Raises ValueError for empty inputs or illegal plugs. Handles
    leading digits and reserved hard/soft keywords.

    Generated by Gemini - January 24, 2026
    """

    if not plug or not all(c.isalnum() or c == "_" for c in plug):
        raise ValueError(
            f"Invalid plug: '{plug}'. Must be non-empty and alphanumeric.",
        )
    if not name:
        raise ValueError("Input string cannot be empty.")

    plugged_name = re.sub(r"\W", plug, name)

    if plugged_name[0].isdigit():
        if plug[0].isdigit():
            plugged_name = f"_{plugged_name}"
        else:
            plugged_name = f"{plug}{plugged_name}"

    if keyword.iskeyword(plugged_name) or keyword.issoftkeyword(plugged_name):
        plugged_name = f"{plugged_name}_"

    return plugged_name


def pythonize_name(name: str) -> str:
    if not name:
        return name
    if name.isupper():
        return name.lower()
    return name[0].lower() + ''.join(
        '_' + c.lower() if c.isupper() else c for c in name[1:]
    )


def prints(*args, **kwargs: Any) -> str:
    with StringIO() as f:
        kwargs['file'] = f
        kwargs['end'] = ''
        print(*args, **kwargs)
        return f.getvalue()
